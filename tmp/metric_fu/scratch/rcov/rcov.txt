
Smartdict

Smartdict::Command
  methods
    #extract_arguments_and_options
    .options
      raises Smartdict::Error if other than hash is passed
    .run
      create new command with passed args and executes it
    .help_message
      returns help message
    .help_syntax_message
      returns formatted syntax message
    .help_usage_message
      returns formatted usage message
  subclass
    summary_message
      is not overalped
    known_arguments
      should not be overalped
    known_options
      should not be overalped
    arguments are initialized
      with passed values
      with default values if it't specified
      raises Smartdict::Error when not enough arguments are provided
    options are initialized
      with passed values
      with static default values
      with values defined in block

Finished in 0.04654 seconds
15 examples, 0 failures
================================================================================
lib/smartdict/core/command_manager.rb
================================================================================
   require 'singleton'
   
   class Smartdict::Core::CommandManager
     include Singleton 
   
     attr_reader :commands
   
     def initialize
!!     @commands = {}
!!     register_command :help     , Smartdict::Commands::HelpCommand
!!     register_command :hello    , Smartdict::Commands::HelloCommand
!!     register_command :translate, Smartdict::Commands::TranslateCommand
!!   end
   
     def register_command(name, klass)
!!     klass.command_name = name.to_s
!!     @commands[name.to_s] = klass
!!   end
   
     def run(args)
!!     cmd_name = args.shift
!!     case cmd_name 
!!     when '-h', '--help', 'help'
!!       run_command :help, args
!!     else
!!       run_command cmd_name, args
!!     end
!!   end
   
     def run_command(name, args = [])
!!     @commands[name.to_s].run(args)
!!   end
   
     def find_command(name)
!!     @commands[name.to_s]
!!   end
!! end
================================================================================
lib/smartdict/core/plugin_manager.rb
================================================================================
   module Smartdict::Core::PluginManager
     include Smartdict::Core::HasLog
     extend self
   
     def load_plugins!
!!     configatron.plugins.each do |plugin|
!!       load_plugin(plugin)
!!     end
!!   end
   
   
     private
   
     def load_plugin(name)
!!     log.info "Loading #{name} plugin"
!!     require plugin_file_path(name)
!!   rescue LoadError 
!!     begin
!!       require "smartdict/plugins/#{name}"
!!     rescue LoadError
!!       log.error "Plugin #{name} not found in plugins dir or rubygems"
!!     end
!!   end
   
     def plugin_file_path(plugin_name)
!!     File.join(configatron.plugins_dir, plugin_name, 'lib', plugin_name)
!!   end
!! end
================================================================================
lib/smartdict/commands/help_command.rb
================================================================================
   class Smartdict::Commands::HelpCommand < Smartdict::Command
     arguments :command
     default   :command => nil
   
     name        "help"
     summary     "Show help message"
     description "Smartdict is a dictionary designed to improve you knowledge of foreign languages."
     syntax <<-SYNTAX
       smartdict COMMAND [arguments...] [options...]
       #{prog_name} COMMAND
       smartdict --help
       smartdict --version
     SYNTAX
   
     def execute
!!     if cmd_name = @arguments[:command]
!!       if cmd_class = command_manager.find_command(cmd_name)
!!         puts cmd_class.help_message
!!       else
!!         abort "Uknown command: #{cmd_name}"
!!       end
!!     else
!!       puts help_message
!!     end
!!   end
   
     def help_message
!!     message = "#{description_message}\n\n"
!!     message << "#{self.class.help_syntax_message}\n"
!!     message << help_commands_message
!!   end
   
     def command_manager
!!     Smartdict::Core::CommandManager.instance
!!   end
   
     def help_commands_message
!!     width = command_manager.commands.keys.map(&:size).max
!!     result = " " * INDENT_SIZE + "Commands:\n"
!!     command_manager.commands.each do |command_name, command_class|
!!       result << " " * 2 * INDENT_SIZE + "#{command_name.ljust(width)}"
!!       result << "    #{command_class.summary_message}\n"
!!     end
!!     result
!!   end
!! end
================================================================================
lib/smartdict.rb
================================================================================
   require 'rubygems'
   
   require 'active_support/core_ext/class'
   
   $LOAD_PATH.unshift File.expand_path(File.dirname(__FILE__))
   
   module Smartdict; end
   
   require 'configatron'
   require "smartdict/core"
   require "smartdict/commands"
   require "smartdict/models"
   
   module Smartdict
     class Error < ::Exception; end
   
     #autoload 
   
     ENVIRONMENTS = [:user, :test, :cucumber]
   
     class << self
       include Smartdict::Core
   
       def run
!!       init_config
!!       Core::PluginManager.load_plugins!
!!       Dir.mkdir user_dir unless File.exists?(user_dir) 
!!       setup_dm
!!     end
   
       def plugin_manager
!!       @plugin_manager ||= Core::PluginManager.new(plugins_dir)
!!     end
   
       def init_config
!!       default_config_file = File.join(root_dir, 'config', 'default_config.yml')
!!       configatron.configure_from_hash YAML.load_file(default_config_file)
!! 
!!       config_file = File.join(user_dir, 'configuration.yml')
!!       configatron.configure_from_hash YAML.load_file(config_file)
!! 
!!       configatron.plugins_dir = File.join(root_dir, 'plugins')
!!       configatron.store.db = File.join(user_dir, 'database.sqlite')
!!     end
   
   
       def user_dir
!!       dirname = {
!!         :user     => '.smartdict',
!!         :test     => '.smartdict_test', 
!!         :cucumber => '.smartdict_test' }[env]
!!       File.join(home_dir, dirname) 
!!     end
   
       def home_dir
!!       ENV['HOME']
!!     end
   
   
       def env=(environment)
         @env = environment.to_sym
         raise "env must be one of #{ENVIRONMENTS.inspect}" unless ENVIRONMENTS.include?(@env)
       end
   
       def env
!!       @env || raise("No env setted for Smartdict")
!!     end
   
       def log_path
!!       File.join(user_dir, 'smartdict.log')
!!     end
   
       def root_dir
!!       File.join(File.dirname(__FILE__), '..')
!!     end
   
       def plugins_dir
!!       File.join(root_dir, 'plugins')
!!     end
   
   
       private
   
       def setup_dm
!!       case configatron.store.adapter
!!       when 'sqlite'
!!         db = configatron.store.db
!!         db_adapted = (db == 'memory') ? ":#{db}:" : "//#{db}"
!!         DataMapper.setup(:default, "sqlite:#{db_adapted}")
!!         if db == 'memory' or !File.exists?(db)
!!           DataMapper.finalize
!!           DataMapper.auto_migrate!
!!         end
!!       else
!!         raise "Not supported adapter #{configatron.store.adapter}" 
!!       end
!!     end
!! 
!!   end
!! end
================================================================================
lib/smartdict/models/pronunciation.rb
================================================================================
   class Smartdict::Models::Pronunciation
     include DataMapper::Resource
     include DataMapper::Validations
   
     property :word_id              , Integer, :key      => true, :min => 1
     property :translation_source_id, Integer, :key      => true, :min => 1
     property :filename             , String
   
     belongs_to :word              , :key => true
     belongs_to :translation_source, :key => true
   
     validates_presence_of :filename
   
     attr_accessor :bin_data, :bin_data_ext
   
    
     # TODO: refactor condition
     before :save do
!!     if bin_data && bin_data_ext
!!       FileUtils.mkdir_p File.dirname(filepath)
!!       File.open(filepath, 'w') {|f| f.write bin_data}
!!     else
!!       puts 'HALT'
!!       p bin_data
!!       p bin_data_ext
!!       throw :halt
!!     end
!!   end
   
     before :valid? do
!!     self.filename ||= gen_filename
!!   end
   
     def filepath
!!     File.join(Smartdict.pronunciations_dir, translation_source.name, word.language.code, filename || gen_filename)
!!   end
     
     private
   
     def gen_filename
!!     escaped_word = word.name.gsub(/[\s']/, '_')
!!     "#{escaped_word}.#{bin_data_ext}"
!!   end
!! end
================================================================================
lib/smartdict/core/log.rb
================================================================================
   require 'logger'
   
   class Smartdict::Core::Log < ::Logger
     def self.root_log
!!     @log ||= self.new(Smartdict.log_path)
!!   end
!! end
================================================================================
lib/smartdict/core/has_log.rb
================================================================================
   require 'smartdict/core/log'
   
   module Smartdict::Core::HasLog
     def self.included(base)
       base.extend         InstanceAndClassMethods
       base.send :include, InstanceAndClassMethods
     end
   
     module InstanceAndClassMethods
       def log
!!       Smartdict::Core::Log.root_log
!!     end
!!   end
!! end
================================================================================
lib/smartdict/models/translation_query.rb
================================================================================
   class Smartdict::Models::TranslationQuery
     include DataMapper::Resource
   
     property :id                , Serial
     property :created_at        , DateTime
     property :word_id           , Integer
     property :target_language_id, Integer
   
     belongs_to :word                       , :key => true
     belongs_to :target_language, 'Language', :key => true
   
     before :save do
!!     self.created_at = Time.now
!!   end
!! end
================================================================================
lib/smartdict/commands/hello_command.rb
================================================================================
   class Smartdict::Commands::HelloCommand < Smartdict::Command
     # arguments and their default values
     arguments :name
     default   :name => "world"
   
     # options and their default values.
     options :greating => "Hello",
             :today => lambda { Time.now.strftime("%A") }
   
     # Other helpful information about the command
     name        "hello"
     summary     "Summary for the hello command"
     description "Demonstrates how Command class works"
     syntax      "#{prog_name} NAME [--greating GREATING] [--today DAY]"
     usage <<-USAGE
       #{prog_name}         
       #{prog_name} Sergey
       #{prog_name} --today Friday
     USAGE
   
     # This method runs when command executes.
     def execute
!!     puts "#{@options[:greating]} #{@arguments[:name]}! Today is #{@options[:today]}."
!!   end
!! end
================================================================================
lib/smartdict/models/word_class.rb
================================================================================
   # Word class is the same what is type of speech and lexical class
   class Smartdict::Models::WordClass
     include DataMapper::Resource
   
     property :id,   Serial
     property :name, String, :required => true
   
     has n, :translations
   end
================================================================================
lib/smartdict/models/translation_source.rb
================================================================================
   class Smartdict::Models::TranslationSource
     include DataMapper::Resource
     include DataMapper::Validations
   
     property :id  , Serial
     property :name, String
   
     has n, :translations
     has n, :pronunciations
   
     validates_presence_of :name
     validates_uniqueness_of :name
   end
================================================================================
lib/smartdict/commands/translate_command.rb
================================================================================
   class Smartdict::Commands::TranslateCommand < Smartdict::Command
     summary     "Translate a word"
     description "Translate a word"
     syntax       "#{prog_name} <WORD> [--from LANGUAGE] [--to LANGUAGE]"
     usage <<-USAGE
       #{prog_name} hello
       #{prog_name} again --from en
       #{prog_name} again --to ru
     USAGE
   
     def execute
   
     end
   end
================================================================================
lib/smartdict/models/word.rb
================================================================================
   class Smartdict::Models::Word
     include DataMapper::Resource
   
     property :id,            Serial
     property :name,          String, :required => true
     property :transcription, String
   
     belongs_to :language, :required  => true
     has n, :translations, :child_key => :source_id
     has n, :pronunciations
   end
================================================================================
lib/smartdict/models.rb
================================================================================
   module Smartdict::Models; end
   
   # rubygems
   require 'dm-core'          #, '1.0.2'
   require 'dm-validations'   #, '1.0.2'
   require 'dm-migrations'    #, '1.0.2'
   require 'dm-sqlite-adapter'#, '1.0.2'
   
   # models
   %w{language pronunciation translation translation_query translation_source word word_class}.each do |model|
     require "smartdict/models/#{model}"
   end
================================================================================
lib/smartdict/core.rb
================================================================================
   module Smartdict::Core; end
   
   require 'smartdict/core/has_log'
   
   Dir.glob("#{File.dirname(__FILE__)}/core/*rb").each do |file|
     require file
   end
================================================================================
lib/smartdict/command.rb
================================================================================
   # Basic class for all command classes.
   #
   # == Usage:
   #   class Smartdict::Commands::HelloCommand < Smartdict::Command
   #     # arguments and their default values
   #     arguments :name
   #     default   :name => "world"
   #   
   #     # options and their default values.
   #     options :greating => "Hello",
   #             :today => lambda { Time.now.strftime("%A") }
   #   
   #     # Other helpful information about the command
   #     name        "hello"
   #     summary     "Summary for the hello command"
   #     description "Demonstrates how Command class works"
   #     syntax      "#{prog_name} NAME [--greating GREATING] [--today DAY]"
   #     usage <<-USAGE
   #       #{prog_name}         
   #       #{prog_name} Sergey
   #       #{prog_name} --today Friday
   #     USAGE
   #   
   #     # This method runs when command executes.
   #     def execute
   #       puts "#{@options[:greating]} #{@arguments[:name]}! Today is #{@options[:today]}."
   #     end
   #   end
   #   
   #   # == Output:
   #   # smartdict hello
   #   # Hello world! Today is Monday.
   #   #
   #   # smartdict hello Sergey
   #   # Hello Sergey! Today is Monday.
   #   # 
   #   # smartdict hello Sergey --today Friday
   #   # Hello Sergey! Today is Friday.
   class Smartdict::Command
     # Number of spaces for indent.
     INDENT_SIZE = 2
   
     # array with available arguments
     class_attribute :known_arguments
   
     # hash with default values for {known_arguments}.
     class_attribute :default_argument_values
   
     # hash with names of options and default values
     class_attribute :known_options
   
     # short summary message for a command
     class_attribute :summary_message
   
     # command description
     class_attribute :description_message
   
     # command name
     class_attribute :command_name
   
     # multi line text with syntax format
     class_attribute :syntax_message
   
     # multi line text with usage example
     class_attribute :usage_message
   
     # Runs command.
     # @param [Array] args arguments passed from the command line
     def self.run(args)
       self.new(args).execute
     end
   
     # Defines available arguments and their order. 
     def self.arguments(*argument_names)
       self.known_arguments = argument_names
     end
   
     # Sets default values for arguments.
     # @param [Hash] values
     def self.default(values)
       self.default_argument_values = values
     end
   
     # Defines available options with their default values.
     # == Usage:
     #   options :to => "en",
     #           :from => lambda { Settings.current_language }
     def self.options(options = {})
       raise Smartdict::Error.new("options must be a hash") unless options.is_a? Hash
       self.known_options = options
     end
   
     # Sets summary message for a command.
     def self.summary(summary)
       self.summary_message = summary
     end
   
     # Sets description message for a command.
     def self.description(description)
       self.description_message = description
     end
   
     # Defines name of a command.
     def self.name(name)
       self.command_name = name
     end
   
     # Sets syntax message.
     # @param [String] syntax multi line text with number of syntax examples
     def self.syntax(syntax)
       self.syntax_message = syntax
     end
   
     # Sets usage examples
     # @param [String] usage multi line text with number of usage examples.
     def self.usage(usage)
       self.usage_message = usage
     end
   
     # @return [String] program name. It's meant to be used in usage examples.
     def self.prog_name
       "smartdict #{command_name}"
     end
   
     # @return [String] help message for the command to be displayed.
     def self.help_message
       message = "#{description_message}\n\n" 
       message << "#{help_syntax_message}\n" 
       message << "#{help_usage_message}\n"
     end
   
     # @return [String] syntax part of the help message.
     def self.help_syntax_message
       result = " " * INDENT_SIZE + "Syntax:\n"
       syntax_message.split("\n").map do |line|
         result << " " * INDENT_SIZE * 2 + "#{line.strip}\n"
       end
       result
     end
   
     # @return [String] usage part of the help message.
     def self.help_usage_message
       result = " " * INDENT_SIZE + "Usage:\n"
       usage_message.split("\n").map do |line|
         result << " " * INDENT_SIZE * 2 + "#{line.strip}\n"
       end
       result
     end
   
     # Sets default values for class attributes.
     def self.inherited(base)
       base.known_arguments ||= []
       base.default_argument_values ||= {}
       base.known_options ||= {}
     end
   
   
   
     # @param [Array] args arguments passed from the command line
     def initialize(args = [])
       set_arguments_and_options!(args)
     end
   
     # Parses all passed arguments and initializes @arguments and @options variables.
     # @param [Array] args arguments passed from the command line
     def set_arguments_and_options!(args)
       arguments, options = extract_arguments_and_options(args)
       set_arguments!(arguments)
       set_options!(options)
     end
   
     # Splits input args to arguments and options.
     # Returns arguments as an array and options as a hash.
     def extract_arguments_and_options(args)
       arguments = []
       options = {}
       args = args.dup
       while value = args.shift
         if match = value.match(/^--(\w+)/)
           options[match[1].to_sym] = args.shift
         else
           arguments << value
         end
       end
       [arguments, options]
     end
   
     # Initializes @arguments variable.
     # If no argument was passed then it uses default value.
     def set_arguments!(arg_values)
       @arguments = {}
       known_arguments.each_with_index do |arg_name, index|
         if value = arg_values[index]
           @arguments[arg_name.to_sym] = value
         elsif default_argument_values.has_key?(arg_name.to_sym)
           @arguments[arg_name.to_sym] = default_argument_values[arg_name.to_sym]
         else
           raise Smartdict::Error.new("Argument `#{arg_name}` is not passed")
         end
       end
     end
   
     # Initializes @options variable.
     # If no argument was passed then it uses default value.
     def set_options!(options)
       @options = {}
       known_options.each do |opt_name, default_value|
         value = options[opt_name]
         unless value
           value = case default_value
             when Proc then default_value.call
             else default_value
           end
         end
         @options[opt_name] = value
       end
     end
   
   end
================================================================================
lib/smartdict/commands.rb
================================================================================
   
   module Smartdict::Commands
   end
   
   require 'smartdict/command'
   
   Dir.glob("#{File.dirname(__FILE__)}/commands/*rb").each do |file|
     require file
   end
================================================================================
lib/smartdict/models/language.rb
================================================================================
   class Smartdict::Models::Language
     include DataMapper::Resource
     include DataMapper::Validations
   
     property :id  , Serial
     property :name, String
     property :code, String #, :length => 2
   
     has n, :words
   
     validates_presence_of :name
     validates_presence_of :code
     validates_uniqueness_of :name, :code
   end
================================================================================
lib/smartdict/models/translation.rb
================================================================================
   class Smartdict::Models::Translation
     include DataMapper::Resource
   
     property :source_id            , Integer, :key => true, :min => 1
     property :target_id            , Integer, :key => true, :min => 1
     property :word_class_id        , Integer, :key => true, :min => 1
     property :translation_source_id, Integer, :key => true, :min => 1
   
     belongs_to :source,        'Word', :key =>  true
     belongs_to :target,        'Word', :key =>  true
     belongs_to :word_class,            :key =>  true
     belongs_to :translation_source,    :key =>  true
   end
